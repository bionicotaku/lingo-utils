// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package outboxsql

import (
	"context"

	uuid "github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const claimPendingOutboxEvents = `-- name: ClaimPendingOutboxEvents :many
WITH candidates AS (
    SELECT o.event_id
    FROM outbox_events o
    WHERE o.published_at IS NULL
      AND o.available_at <= $1
      AND (o.lock_token IS NULL OR o.locked_at <= $2)
    ORDER BY o.available_at
    FOR UPDATE SKIP LOCKED
    LIMIT $3
)
UPDATE outbox_events AS o
SET lock_token = $4,
    locked_at = now()
FROM candidates
WHERE o.event_id = candidates.event_id
RETURNING
    o.event_id,
    o.aggregate_type,
    o.aggregate_id,
    o.event_type,
    o.payload,
    o.headers,
    o.occurred_at,
    o.available_at,
    o.published_at,
    o.delivery_attempts,
    o.last_error,
    o.lock_token,
    o.locked_at
`

type ClaimPendingOutboxEventsParams struct {
	AvailableAt pgtype.Timestamptz `json:"available_at"`
	LockedAt    pgtype.Timestamptz `json:"locked_at"`
	Limit       int32              `json:"limit"`
	LockToken   pgtype.Text        `json:"lock_token"`
}

func (q *Queries) ClaimPendingOutboxEvents(ctx context.Context, arg ClaimPendingOutboxEventsParams) ([]OutboxEvent, error) {
	rows, err := q.db.Query(ctx, claimPendingOutboxEvents,
		arg.AvailableAt,
		arg.LockedAt,
		arg.Limit,
		arg.LockToken,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []OutboxEvent{}
	for rows.Next() {
		var i OutboxEvent
		if err := rows.Scan(
			&i.EventID,
			&i.AggregateType,
			&i.AggregateID,
			&i.EventType,
			&i.Payload,
			&i.Headers,
			&i.OccurredAt,
			&i.AvailableAt,
			&i.PublishedAt,
			&i.DeliveryAttempts,
			&i.LastError,
			&i.LockToken,
			&i.LockedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const countPendingOutboxEvents = `-- name: CountPendingOutboxEvents :one
SELECT COUNT(*)::bigint
FROM outbox_events
WHERE published_at IS NULL
`

func (q *Queries) CountPendingOutboxEvents(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countPendingOutboxEvents)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const getInboxEvent = `-- name: GetInboxEvent :one
SELECT
    event_id,
    source_service,
    event_type,
    aggregate_type,
    aggregate_id,
    payload,
    received_at,
    processed_at,
    last_error
FROM inbox_events
WHERE event_id = $1
`

func (q *Queries) GetInboxEvent(ctx context.Context, eventID uuid.UUID) (InboxEvent, error) {
	row := q.db.QueryRow(ctx, getInboxEvent, eventID)
	var i InboxEvent
	err := row.Scan(
		&i.EventID,
		&i.SourceService,
		&i.EventType,
		&i.AggregateType,
		&i.AggregateID,
		&i.Payload,
		&i.ReceivedAt,
		&i.ProcessedAt,
		&i.LastError,
	)
	return i, err
}

const insertInboxEvent = `-- name: InsertInboxEvent :exec

INSERT INTO inbox_events (
    event_id,
    source_service,
    event_type,
    aggregate_type,
    aggregate_id,
    payload
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6
)
ON CONFLICT (event_id) DO NOTHING
`

type InsertInboxEventParams struct {
	EventID       uuid.UUID   `json:"event_id"`
	SourceService string      `json:"source_service"`
	EventType     string      `json:"event_type"`
	AggregateType pgtype.Text `json:"aggregate_type"`
	AggregateID   pgtype.Text `json:"aggregate_id"`
	Payload       []byte      `json:"payload"`
}

// Inbox 相关查询
func (q *Queries) InsertInboxEvent(ctx context.Context, arg InsertInboxEventParams) error {
	_, err := q.db.Exec(ctx, insertInboxEvent,
		arg.EventID,
		arg.SourceService,
		arg.EventType,
		arg.AggregateType,
		arg.AggregateID,
		arg.Payload,
	)
	return err
}

const insertOutboxEvent = `-- name: InsertOutboxEvent :one

INSERT INTO outbox_events (
    event_id,
    aggregate_type,
    aggregate_id,
    event_type,
    payload,
    headers,
    available_at
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7
)
RETURNING
    event_id,
    aggregate_type,
    aggregate_id,
    event_type,
    payload,
    headers,
    occurred_at,
    available_at,
    published_at,
    delivery_attempts,
    last_error
`

type InsertOutboxEventParams struct {
	EventID       uuid.UUID          `json:"event_id"`
	AggregateType string             `json:"aggregate_type"`
	AggregateID   uuid.UUID          `json:"aggregate_id"`
	EventType     string             `json:"event_type"`
	Payload       []byte             `json:"payload"`
	Headers       []byte             `json:"headers"`
	AvailableAt   pgtype.Timestamptz `json:"available_at"`
}

type InsertOutboxEventRow struct {
	EventID          uuid.UUID          `json:"event_id"`
	AggregateType    string             `json:"aggregate_type"`
	AggregateID      uuid.UUID          `json:"aggregate_id"`
	EventType        string             `json:"event_type"`
	Payload          []byte             `json:"payload"`
	Headers          []byte             `json:"headers"`
	OccurredAt       pgtype.Timestamptz `json:"occurred_at"`
	AvailableAt      pgtype.Timestamptz `json:"available_at"`
	PublishedAt      pgtype.Timestamptz `json:"published_at"`
	DeliveryAttempts int32              `json:"delivery_attempts"`
	LastError        pgtype.Text        `json:"last_error"`
}

// Outbox / Inbox 共享 SQL 查询
func (q *Queries) InsertOutboxEvent(ctx context.Context, arg InsertOutboxEventParams) (InsertOutboxEventRow, error) {
	row := q.db.QueryRow(ctx, insertOutboxEvent,
		arg.EventID,
		arg.AggregateType,
		arg.AggregateID,
		arg.EventType,
		arg.Payload,
		arg.Headers,
		arg.AvailableAt,
	)
	var i InsertOutboxEventRow
	err := row.Scan(
		&i.EventID,
		&i.AggregateType,
		&i.AggregateID,
		&i.EventType,
		&i.Payload,
		&i.Headers,
		&i.OccurredAt,
		&i.AvailableAt,
		&i.PublishedAt,
		&i.DeliveryAttempts,
		&i.LastError,
	)
	return i, err
}

const markInboxEventProcessed = `-- name: MarkInboxEventProcessed :exec
UPDATE inbox_events
SET processed_at = $2,
    last_error = NULL
WHERE event_id = $1
`

type MarkInboxEventProcessedParams struct {
	EventID     uuid.UUID          `json:"event_id"`
	ProcessedAt pgtype.Timestamptz `json:"processed_at"`
}

func (q *Queries) MarkInboxEventProcessed(ctx context.Context, arg MarkInboxEventProcessedParams) error {
	_, err := q.db.Exec(ctx, markInboxEventProcessed, arg.EventID, arg.ProcessedAt)
	return err
}

const markOutboxEventPublished = `-- name: MarkOutboxEventPublished :exec
UPDATE outbox_events
SET published_at = $3,
    delivery_attempts = delivery_attempts + 1,
    last_error = NULL,
    lock_token = NULL,
    locked_at = NULL
WHERE event_id = $1 AND lock_token = $2
`

type MarkOutboxEventPublishedParams struct {
	EventID     uuid.UUID          `json:"event_id"`
	LockToken   pgtype.Text        `json:"lock_token"`
	PublishedAt pgtype.Timestamptz `json:"published_at"`
}

func (q *Queries) MarkOutboxEventPublished(ctx context.Context, arg MarkOutboxEventPublishedParams) error {
	_, err := q.db.Exec(ctx, markOutboxEventPublished, arg.EventID, arg.LockToken, arg.PublishedAt)
	return err
}

const recordInboxEventError = `-- name: RecordInboxEventError :exec
UPDATE inbox_events
SET last_error = $2,
    processed_at = NULL
WHERE event_id = $1
`

type RecordInboxEventErrorParams struct {
	EventID   uuid.UUID   `json:"event_id"`
	LastError pgtype.Text `json:"last_error"`
}

func (q *Queries) RecordInboxEventError(ctx context.Context, arg RecordInboxEventErrorParams) error {
	_, err := q.db.Exec(ctx, recordInboxEventError, arg.EventID, arg.LastError)
	return err
}

const rescheduleOutboxEvent = `-- name: RescheduleOutboxEvent :exec
UPDATE outbox_events
SET delivery_attempts = delivery_attempts + 1,
    last_error = $3,
    available_at = $4,
    lock_token = NULL,
    locked_at = NULL
WHERE event_id = $1 AND lock_token = $2
`

type RescheduleOutboxEventParams struct {
	EventID     uuid.UUID          `json:"event_id"`
	LockToken   pgtype.Text        `json:"lock_token"`
	LastError   pgtype.Text        `json:"last_error"`
	AvailableAt pgtype.Timestamptz `json:"available_at"`
}

func (q *Queries) RescheduleOutboxEvent(ctx context.Context, arg RescheduleOutboxEventParams) error {
	_, err := q.db.Exec(ctx, rescheduleOutboxEvent,
		arg.EventID,
		arg.LockToken,
		arg.LastError,
		arg.AvailableAt,
	)
	return err
}
